#include <opencv2/core/core.hpp> 
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <fstream>


// --------------------------
// Structuring Element Utility Code
// Author: Branden Sammons
// --------------------------


// compile command:
// cl /EHsc structuringElementUtil.cpp /I %OpenCV_Path%\build\include /link /LIBPATH:%OpenCV_Path%\build\x64\vc15\lib opencv_world455.lib

// execute command:
// structuringElementUtil.exe


// Input files
const char* inputfile = "../temp/4.jpg";
const char* outputfile = "../temp/seUtilImage4.jpg";
const char* matfile = "../temp/seUtilMat4.txt";

// Mats
cv::Mat originalImg;
cv::Mat greyImg;
cv::Mat bwImg;
cv::Mat thinMat;
cv::Mat seMat;

// Function prototypes
void thin(cv::Mat inputMat, cv::Mat& destMat);
void reduceMat(cv::Mat inputMat, cv::Mat& destMat);
void writeMatToFile(const std::string& filename, cv::Mat inputMat);


int main() {
	
	originalImg = cv::imread(inputfile, cv::IMREAD_COLOR);

	// ensure image was valid
	if (!originalImg.data) {
		std::cout << "Missing data." << std::endl;
		return -1;
	}
	
	// greyscale the image
	cv::cvtColor(originalImg, greyImg, cv::COLOR_BGR2GRAY);

	// threshold the image (convert to binary)
	cv::threshold(greyImg, bwImg, 100, 1, cv::THRESH_BINARY);

	cv::namedWindow("BW Image", cv::WINDOW_AUTOSIZE);
	cv::imshow("BW Image", (bwImg * 255));
	cv::waitKey(0);

	// Thin the image
	thin(bwImg, thinMat);

	// remove empty rows and columns
	reduceMat(thinMat, seMat);

	cv::namedWindow("Thinned Image", cv::WINDOW_AUTOSIZE);
	cv::imshow("Thinned Image", (seMat * 255));
	cv::waitKey(0);

	// write Image to file
	cv::imwrite(outputfile, (seMat * 255));

	// write Mat to file
	writeMatToFile(matfile, seMat);
	
	// Clean up
	cv::destroyAllWindows();
	return 0;
}

// https://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm
// AND
// https://en.wikipedia.org/wiki/Hit-or-miss_transform
// AND
// https://docs.opencv.org/4.x/db/d06/tutorial_hitOrMiss.html
void thin(cv::Mat inputMat, cv::Mat& destMat) {

	cv::Mat img;
	inputMat.copyTo(img);

	// Structuring Elements
	cv::Mat B1, B2, B3, B4, B5, B6, B7, B8;
	B1 = (cv::Mat_<int>(3, 3) << -1, -1, -1, 0, 1, 0, 1, 1, 1);
	B2 = (cv::Mat_<int>(3, 3) << 0, -1, -1, 1, 1, -1, 0, 1, 0);
	cv::rotate(B1, B3, cv::ROTATE_90_CLOCKWISE);
	cv::rotate(B2, B4, cv::ROTATE_90_CLOCKWISE);
	cv::rotate(B1, B5, cv::ROTATE_180);
	cv::rotate(B2, B6, cv::ROTATE_180);
	cv::rotate(B1, B7, cv::ROTATE_90_COUNTERCLOCKWISE);
	cv::rotate(B2, B8, cv::ROTATE_90_COUNTERCLOCKWISE);
	
	cv::Mat Bn[8] = { B1, B2, B3, B4, B5, B6, B7, B8 };

	// Empty Output Img
	cv::Mat thin = cv::Mat::zeros(inputMat.size(), CV_8UC1);

	while (true) {

		cv::Mat mask = cv::Mat::zeros(inputMat.size(), CV_8UC1);

		for (int i = 0; i < 8; i++) {
			// Hit or Miss
			cv::Mat temp;
			cv::morphologyEx(img, temp, cv::MORPH_HITMISS, Bn[i]);
			cv::bitwise_or(mask, temp, mask);
		}
		
		// Subtraction
		img = img - mask;

		// Convergence
		if (cv::countNonZero(img) == cv::countNonZero(thin)) {
			break;
		};

		img.copyTo(thin);
	}

	thin.copyTo(destMat);
	return;
}

// TODO Documentation
void reduceMat(cv::Mat inputMat, cv::Mat& destMat) {

	// get the horizontal and vertical projections
	cv::Mat horizontalProjection, verticalProjection;
	cv::reduce(inputMat, horizontalProjection, 0, cv::REDUCE_SUM, CV_32F);
	cv::reduce(inputMat, verticalProjection, 1, cv::REDUCE_SUM, CV_32F);

	// Get the start and end of the symbol in both axis
	int minX = 0, maxX = horizontalProjection.cols - 1;
	for (int i = 0; i < horizontalProjection.cols; i++) {
		if (horizontalProjection.at<uint>(0, i) > 0) {
			minX = i;
			break;
		}
	}
	for (int i = horizontalProjection.cols - 1; i >= 0; i--) {
		if (horizontalProjection.at<uint>(0, i) > 0) {
			maxX = i;
			break;
		}
	}

	int minY = 0, maxY = verticalProjection.rows - 1;
	for (int i = 0; i < verticalProjection.rows; i++) {
		if (verticalProjection.at<uint>(i, 0) > 0) {
			minY = i;
			break;
		}
	}
	for (int i = verticalProjection.rows - 1; i >= 0; i--) {
		if (verticalProjection.at<uint>(i, 0) > 0) {
			maxY = i;
			break;
		}
	}

	// copy in the reduced Mat
	cv::Range rRange(minY, maxY + 1);
	cv::Range cRange(minX, maxX + 1);
	
	inputMat(rRange, cRange).copyTo(destMat);
	return;
}

// TODO Documentation
void writeMatToFile(const std::string& filename, cv::Mat inputMat) {

	//uint8_t data[size] = {...};
	//cv::Mat Identifier = cv::Mat(rows, cols, CV_8UC1, data);

	// Create and Open file
	std::ofstream file(filename);

	int rows = inputMat.rows;
	int cols = inputMat.cols;
	int size = inputMat.rows * inputMat.cols;

	file << "// Generated by the Structuring Element Utility" << '\n';

	file << "uint8_t <Identifier>Data[" << size << "] = {" << '\n';

	// Write to file
	for (int r = 0; r < rows; r++) {

		file << '\t'; // insert tab at start of row

		for (int c = 0; c < cols; c++) {
			
			file << (int)(inputMat.at<uint8_t>(r, c));

			// not the last row and last column
			if (!(r == rows - 1 && c == cols - 1)) {
				file << ", ";
			}
		}

		file << '\n'; // insert newline at end of row
	}

	file << "};" << '\n';
	file << "const cv::Mat <Identifier> = cv::Mat(" << inputMat.rows << ", " << inputMat.cols << ", CV_8UC1, <Identifier>Data);" << '\n';

	// Close the File
	file.close();
	return;
}